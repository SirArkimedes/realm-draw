"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
var RealmSyncServerOperatingMode;
(function (RealmSyncServerOperatingMode) {
    RealmSyncServerOperatingMode[RealmSyncServerOperatingMode["MasterWithNoSlave"] = 0] = "MasterWithNoSlave";
    RealmSyncServerOperatingMode[RealmSyncServerOperatingMode["MasterWithAsynchronousSlave"] = 1] = "MasterWithAsynchronousSlave";
    RealmSyncServerOperatingMode[RealmSyncServerOperatingMode["MasterWithSynchronousSlave"] = 2] = "MasterWithSynchronousSlave";
    RealmSyncServerOperatingMode[RealmSyncServerOperatingMode["Slave"] = 3] = "Slave";
})(RealmSyncServerOperatingMode = exports.RealmSyncServerOperatingMode || (exports.RealmSyncServerOperatingMode = {}));
const binding = require(`../compiled/${process.platform}-${process.arch}/node-v${process.versions.modules}-Release/realm-sync-server.node`);
const debugBinding = require(`../compiled/${process.platform}-${process.arch}/node-v${process.versions.modules}-Debug/realm-sync-server.node`);
class RealmSyncServer {
    constructor(config) {
        if (!config.dataPath) {
            throw new Error("dataPath is not defined");
        }
        if (!fs.existsSync(config.dataPath)) {
            throw new Error(`dataPath "${config.dataPath}" does not exist`);
        }
        if (!config.publicKeyPath) {
            throw new Error("publicKeyPath is not defined");
        }
        if (!fs.existsSync(config.publicKeyPath)) {
            throw new Error(`publicKeyPath "${config.publicKeyPath}" does not exist`);
        }
        if (config.logLsofPeriod < 0) {
            throw new Error("logLsofPeriod must not be negative");
        }
        const nullLogger = (level, msg) => {
        };
        const fatalErrorCallback = (name, message) => {
            console.error('Sync worker received fatal error', { name, message });
            process.exit(1);
        };
        const nullSlaveStatusCallback = (id, upToDate) => {
        };
        const superConfig = {
            id: config.id,
            dataPath: config.dataPath,
            listenAddress: config.listenAddress,
            listenPort: config.listenPort ? String(config.listenPort) : undefined,
            ssl: config.ssl,
            sslCertificatePath: config.sslCertificatePath,
            sslCertificateKeyPath: config.sslCertificateKeyPath,
            logCallback: config.logCallback || nullLogger,
            logLevel: config.logLevel,
            errorCallback: config.errorCallback || fatalErrorCallback,
            slaveStatusCallback: config.slaveStatusCallback || nullSlaveStatusCallback,
            masterAddress: config.masterAddress,
            masterPort: config.masterPort ? String(config.masterPort) : undefined,
            masterSlaveSharedSecret: config.masterSlaveSharedSecret,
            masterSlaveSsl: config.masterSlaveSsl,
            masterSlaveSslTrustCertificatePath: config.masterSlaveSslTrustCertificatePath,
            operatingMode: config.operatingMode || RealmSyncServerOperatingMode.MasterWithNoSlave,
            publicKeyPath: config.publicKeyPath,
            statsEndpoint: config.statsEndpoint,
            featureToken: config.featureToken,
            enableDownloadLogCompaction: (config.enableDownloadLogCompaction === undefined ? true :
                config.enableDownloadLogCompaction),
            maxDownloadSize: config.maxDownloadSize,
            listenBacklog: config.listenBacklog,
            tcpNoDelay: config.tcpNoDelay,
            isSubtierServer: config.isSubtierServer,
            upstreamUrl: config.upstreamUrl,
            upstreamAccessToken: config.upstreamAccessToken,
            logLsofPeriod: config.logLsofPeriod || 0,
            enableRealmStateSizeReporting: config.enableRealmStateSizeReporting,
            historyTtl: config.historyTtl,
            enableLogCompaction: config.enableLogCompaction,
            historyCompactionInterval: config.historyCompactionInterval,
            shouldCompactRealmsAtStart: config.shouldCompactRealmsAtStart,
            shouldPerformPartialSyncAtStart: config.shouldPerformPartialSyncAtStart,
        };
        const chosenBinding = config.enableDebugMode === true ? debugBinding : binding;
        this.syncServer = new chosenBinding.RealmServer(superConfig);
    }
    start() {
        return new Promise((resolve, reject) => {
            this.syncServer.start((error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
    }
    stop() {
        return new Promise((resolve, reject) => {
            this.syncServer.stop((error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
    }
    address() {
        return this.syncServer.address();
    }
    stopSyncAndWaitForBackupCompletion(timeout) {
        return new Promise((resolve, reject) => {
            const callback = (didComplete) => {
                if (didComplete) {
                    resolve();
                }
                else {
                    reject("Backup is not complete");
                }
            };
            try {
                this.syncServer.stopSyncAndWaitForBackupCompletion(callback, timeout);
            }
            catch (e) {
                reject(e);
            }
        });
    }
}
exports.RealmSyncServer = RealmSyncServer;
//# sourceMappingURL=index.js.map