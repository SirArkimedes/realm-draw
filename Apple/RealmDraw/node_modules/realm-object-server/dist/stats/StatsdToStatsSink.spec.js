"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const events_1 = require("events");
const shared_1 = require("../shared");
const _1 = require(".");
describe("StatsdToStatsSink", () => {
    const logger = new shared_1.ConsoleLogger("warn");
    let emitter;
    beforeEach(() => __awaiter(this, void 0, void 0, function* () {
        emitter = new events_1.EventEmitter();
    }));
    afterEach(() => {
        if (emitter) {
            emitter.removeAllListeners();
            emitter = null;
        }
    });
    const start = (labels = {}) => {
        const statsSink = new _1.StandaloneStats();
        const statsdToStatsSink = new _1.StatsdToStatsSink({
            logger,
            statsSink,
            labels,
        });
        return { statsSink, statsdToStatsSink };
    };
    it("can be started and stopped", () => __awaiter(this, void 0, void 0, function* () {
        const statsSink = new _1.StandaloneStats();
        const statsdToStatsSink = _1.StatsdToStatsSink.createAndListen({
            logger,
            statsSink,
            labels: {},
        }, emitter);
        chai_1.expect(() => {
            statsdToStatsSink.listenTo({});
        }).to.throw("Already listening to another receiver");
        statsdToStatsSink.stop();
        chai_1.expect(() => {
            statsdToStatsSink.stop();
        }).to.throw("Not listening to a receiver");
    }));
    it("can consume a simple counter metric", () => __awaiter(this, void 0, void 0, function* () {
        const { statsSink, statsdToStatsSink } = start();
        statsdToStatsSink.listenTo(emitter);
        const metric = {
            name: "realm.localhost.protocol.bytes.sent",
            labels: {},
            stats: [
                { type: _1.MetricType.Counter, value: "10" },
            ],
        };
        emitter.emit("metric", metric);
        yield shared_1.delay(10);
        const values = yield statsSink.getInstantValues("ros_sync_protocol_bytes_sent", {});
        chai_1.expect(values).to.be.an("array").with.length(1);
        chai_1.expect(values[0].value).to.equal(10);
    }));
    it("can consume metrics with labels", () => __awaiter(this, void 0, void 0, function* () {
        const { statsSink, statsdToStatsSink } = start();
        statsdToStatsSink.listenTo(emitter);
        const counter = statsSink.counter({
            name: "some_counter_with_labels",
            help: "Just testing ...",
            labelNames: ["key"],
        });
        statsdToStatsSink.counters["some_counter_with_labels"] = counter;
        const metric1 = {
            name: "realm.localhost.some.counter.with.labels",
            labels: { key: "one" },
            stats: [
                { type: _1.MetricType.Counter, value: "1" },
            ],
        };
        const metric2 = {
            name: "realm.localhost.some.counter.with.labels",
            labels: { key: "two" },
            stats: [
                { type: _1.MetricType.Counter, value: "2" },
            ],
        };
        emitter.emit("metric", metric1);
        emitter.emit("metric", metric2);
        yield shared_1.delay(10);
        const values = yield statsSink.getInstantValues("some_counter_with_labels", {});
        chai_1.expect(values).to.have.length(2);
        chai_1.expect(values[0].value).to.equal(1);
        chai_1.expect(values[1].value).to.equal(2);
        const values1 = yield statsSink.getInstantValues("some_counter_with_labels", { key: "one" });
        chai_1.expect(values1).to.have.length(1);
        chai_1.expect(values1[0].value).to.equal(1);
        const values2 = yield statsSink.getInstantValues("some_counter_with_labels", { key: "two" });
        chai_1.expect(values2).to.have.length(1);
        chai_1.expect(values2[0].value).to.equal(2);
    }));
    it("can consume a metric with multiple stats", () => __awaiter(this, void 0, void 0, function* () {
        const { statsSink, statsdToStatsSink } = start();
        statsdToStatsSink.listenTo(emitter);
        const metric = {
            name: "realm.localhost.protocol.bytes.sent",
            labels: {},
            stats: [
                { type: _1.MetricType.Counter, value: "5" },
                { type: _1.MetricType.Counter, value: "7" },
                { type: _1.MetricType.Counter, value: "9" },
            ],
        };
        emitter.emit("metric", metric);
        yield shared_1.delay(10);
        const values = yield statsSink.getInstantValues("ros_sync_protocol_bytes_sent", {});
        chai_1.expect(values).to.be.an("array").with.length(1);
        chai_1.expect(values[0].value).to.equal(21);
    }));
});
//# sourceMappingURL=StatsdToStatsSink.spec.js.map