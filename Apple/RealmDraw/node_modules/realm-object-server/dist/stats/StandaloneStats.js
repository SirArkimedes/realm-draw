"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
class StandaloneStatsMetric {
    constructor(params) {
        this.values = {};
        this.name = params.name;
        this.help = params.help;
        this.labelNames = params.labelNames || [];
    }
    getInstantValues(labels) {
        return this.getValuesAsArray()
            .filter((value) => {
            return this.testLabels(labels, value.labels);
        });
    }
    getValue(labels) {
        this.checkLabelNames(labels);
        const labelHash = this.generateLabelHash(labels);
        if (labelHash in this.values) {
            return this.values[labelHash];
        }
        else {
            const value = { labels, value: 0 };
            this.values[labelHash] = value;
            return value;
        }
    }
    getValuesAsArray() {
        return Object.keys(this.values).map(labelHash => this.values[labelHash]);
    }
    testLabels(expectedLabels, actualLabels) {
        const labelNames = Object.keys(expectedLabels);
        for (const labelName of labelNames) {
            if (actualLabels[labelName] !== expectedLabels[labelName]) {
                return false;
            }
        }
        return true;
    }
    checkLabelNames(labels) {
        const labelNames = Object.keys(labels);
        for (const labelName of labelNames) {
            if (this.labelNames.indexOf(labelName) === -1) {
                throw new Error(`Unexpected label named ${labelName}`);
            }
        }
    }
    generateLabelHash(labels) {
        return Object.keys(labels)
            .sort()
            .map(labelName => `${labelName}=${labels[labelName]}`)
            .join(",");
    }
}
exports.StandaloneStatsMetric = StandaloneStatsMetric;
class StandaloneStatsCounter extends StandaloneStatsMetric {
    inc(labels, value = 1) {
        this.getValue(labels).value += value;
    }
    reset(labels, value = 0) {
        this.getValue(labels).value = value;
    }
}
exports.StandaloneStatsCounter = StandaloneStatsCounter;
class StandaloneStatsGauge extends StandaloneStatsCounter {
    dec(labels, value = 1) {
        this.getValue(labels).value -= value;
    }
    set(labels, value) {
        this.getValue(labels).value = value;
    }
}
exports.StandaloneStatsGauge = StandaloneStatsGauge;
class StandaloneStatsHistogram extends StandaloneStatsMetric {
    observe(labels, value) {
        this.getValue(labels).value = value;
    }
    startTimer(labels) {
        const start = process.hrtime();
        return () => {
            const delta = process.hrtime(start);
            this.observe(labels, delta[0] + delta[1] / 1e9);
        };
    }
}
exports.StandaloneStatsHistogram = StandaloneStatsHistogram;
class StandaloneStats {
    constructor() {
        this.metrics = {};
    }
    counter(params) {
        const counter = new StandaloneStatsCounter(params);
        this.metrics[params.name] = counter;
        return counter;
    }
    gauge(params) {
        const gauge = new StandaloneStatsGauge(params);
        this.metrics[params.name] = gauge;
        return gauge;
    }
    histogram(params) {
        const histogram = new StandaloneStatsHistogram(params);
        this.metrics[params.name] = histogram;
        return histogram;
    }
    getInstantValues(name, labels = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const metric = this.metrics[name];
            if (metric) {
                return metric
                    .getInstantValues(labels)
                    .map(labelledValue => {
                    return Object.assign({ labels: Object.assign({}, labelledValue.labels) }, labelledValue);
                });
            }
            else {
                return [];
            }
        });
    }
}
exports.StandaloneStats = StandaloneStats;
//# sourceMappingURL=StandaloneStats.js.map