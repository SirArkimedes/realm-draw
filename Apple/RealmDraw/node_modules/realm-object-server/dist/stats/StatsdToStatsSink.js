"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Statsd_1 = require("./Statsd");
const SyncWorkerCounters = {
    authentication_failed: {
        help: "Authentication failed",
    },
    connection_started: {
        help: "Connection started",
    },
    connection_terminated: {
        help: "Connection terminated",
    },
    session_started: {
        help: "Session started",
    },
    session_terminated: {
        help: "Session terminated",
    },
    session_failed: {
        help: "Session failed",
    },
    protocol_violated: {
        help: "Protocol violated",
    },
    protocol_bytes_sent: {
        help: "Total bytes sent",
    },
    protocol_bytes_received: {
        help: "Total bytes received",
    },
    changeset_integrated: {
        help: "Changesets integrated",
    },
    download_constructed: {
        help: "Downloads constructed",
    },
    permission_denied: {
        help: "Permission denied",
    },
    client_unsyncable: {
        help: "Client unsyncable",
    },
    merges_performed: {
        help: "Merges performed",
    },
    connection_term_end_of_input: {
        name: "ros_sync_conn_term_end_of_input",
        help: "End of input",
    },
    connection_term_connection_reset_error: {
        name: "ros_sync_conn_term_connection_reset_error",
        help: "Connection reset",
    },
    connection_term_broken_pipe_error: {
        name: "ros_sync_conn_term_broken_pipe_error",
        help: "Broken pipe",
    },
    connection_term_system_error: {
        name: "ros_sync_conn_term_system_error",
        help: "System error",
    },
    connection_term_network_error: {
        name: "ros_sync_conn_term_network_error",
        help: "Network error",
    },
    connection_term_ssl_error: {
        name: "ros_sync_conn_term_ssl_error",
        help: "TLS error",
    },
    connection_term_http_error: {
        name: "ros_sync_conn_term_http_error",
        help: "HTTP error",
    },
    connection_term_websocket_error: {
        name: "ros_sync_conn_term_websocket_error",
        help: "WebSocker error",
    },
    connection_term_sync_protocol_error: {
        name: "ros_sync_conn_term_sync_protocol_error",
        help: "Sync protocol error",
    },
    connection_term_error_of_unexpected_category: {
        name: "ros_sync_conn_term_error_of_unexpected_category",
        help: "Error of unexpected category",
    },
    connection_term_superseded_session: {
        name: "ros_sync_conn_term_superseded_session",
        help: "Superseded session",
    },
    connection_term_heartbeat_timeout: {
        name: "ros_sync_conn_term_heartbeat_timeout",
        help: "Heartbeat timeout",
    },
    connection_term_http_response_written: {
        name: "ros_sync_conn_term_http_response_written",
        help: "HTTP response written",
    },
};
const SyncWorkerGauges = {
    protocol_bytes_sent: {
        name: "ros_sync_protocol_bytes_sent_gauge",
        help: "Total bytes sent",
    },
    protocol_bytes_received: {
        name: "ros_sync_protocol_bytes_received_gauge",
        help: "Total bytes received",
    },
    connection_online: {
        help: "Connections online",
    },
    connection_total: {
        help: "Connections total",
    },
    session_online: {
        help: "Sessions online",
    },
    session_total: {
        help: "Sessions total",
    },
    realms_open: {
        help: "Realms open",
    },
    realm_state_size: {
        help: "Size of realm states in bytes",
        labelNames: ["path"],
    },
    event_loop_saturation: {
        help: "Event loop saturation",
    },
    event_loop_inefficiency: {
        help: "Event loop inefficiency",
    },
};
const SyncWorkerHistograms = {
    download_constructed: {
        name: "ros_sync_download_constructed_ms",
        help: "Downloads constructed durations in ms",
    },
    download_constructed_size: {
        name: "ros_sync_download_constructed_bytes",
        help: "Downloads constructed sizes in bytes",
    },
    changeset_integrated: {
        name: "ros_sync_changeset_integrated_ms",
        help: "Changeset integrated durations in ms",
    },
    changeset_integrated_size: {
        name: "ros_sync_changeset_integrated_bytes",
        help: "Changeset integrated sizes in bytes",
    },
    changeset_integrated_merges: {
        help: "Changeset integrated merge counts",
    },
    ping_rtt: {
        name: "ros_sync_ping_rtt_ms",
        help: "Ping round-trip-time in ms",
    },
};
class StatsdToStatsSink {
    constructor(config) {
        this.gauges = {};
        this.counters = {};
        this.histograms = {};
        this.handleMetric = (metric) => {
            const nameParts = metric.name.split(".");
            const realmPart = nameParts.shift();
            if (realmPart !== "realm") {
                this.logger.warn(`Skipping metric named "${metric.name}", it must start with "realm."`);
                return;
            }
            const host = nameParts.shift();
            if (!host) {
                this.logger.warn(`Skipping metric named "${metric.name}", expected a host`);
                return;
            }
            const localMetricName = nameParts.join("_");
            const labels = Object.assign({}, this.labels, metric.labels);
            for (const stat of metric.stats) {
                if (stat.type === Statsd_1.MetricType.Gauge) {
                    const gauge = this.gauges[localMetricName];
                    if (gauge) {
                        gauge.set(labels, Number(stat.value) || 0);
                    }
                    else {
                        this.logger.warn(`Unexpected gauge named "${localMetricName}"`);
                    }
                }
                else if (stat.type === Statsd_1.MetricType.Counter) {
                    const counter = this.counters[localMetricName];
                    if (counter) {
                        counter.inc(labels, Number(stat.value) || 0);
                    }
                    else {
                        this.logger.warn(`Unexpected counter named "${localMetricName}"`);
                    }
                }
                else if (stat.type === Statsd_1.MetricType.Histogram) {
                    const histogram = this.histograms[localMetricName];
                    if (histogram) {
                        histogram.observe(labels, Number(stat.value) || 0);
                    }
                    else {
                        this.logger.warn(`Unexpected histogram named "${localMetricName}"`);
                    }
                }
                else {
                    this.logger.warn(`Unexpected metric type: "${stat.type}" of "${localMetricName}"`);
                }
            }
        };
        this.logger = config.logger;
        this.labels = config.labels;
        for (const name in SyncWorkerCounters) {
            this.counters[name] = config.statsSink.counter(Object.assign({ name: `ros_sync_${name}` }, SyncWorkerCounters[name]));
        }
        for (const name in SyncWorkerGauges) {
            this.gauges[name] = config.statsSink.gauge(Object.assign({ name: `ros_sync_${name}` }, SyncWorkerGauges[name]));
        }
        for (const name in SyncWorkerHistograms) {
            this.histograms[name] = config.statsSink.histogram(Object.assign({ name: `ros_sync_${name}` }, SyncWorkerHistograms[name]));
        }
    }
    static createAndListen(config, receiver) {
        const instance = new StatsdToStatsSink(config);
        instance.listenTo(receiver);
        return instance;
    }
    listenTo(receiver) {
        if (this.receiver) {
            throw new Error("Already listening to another receiver");
        }
        else {
            this.receiver = receiver;
            this.receiver.addListener("metric", this.handleMetric);
        }
    }
    stop() {
        if (this.receiver) {
            this.receiver.removeListener("metric", this.handleMetric);
            delete this.receiver;
        }
        else {
            throw new Error("Not listening to a receiver");
        }
    }
}
exports.StatsdToStatsSink = StatsdToStatsSink;
//# sourceMappingURL=StatsdToStatsSink.js.map