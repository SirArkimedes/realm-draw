"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const dgram = require("dgram");
const Logger_1 = require("../shared/Logger");
const StatsdStatsSink_1 = require("./StatsdStatsSink");
describe("StatsdStatsSink", () => {
    it("can be constructed from defaults", () => {
        const statsSink = new StatsdStatsSink_1.StatsdStatsSink();
        chai_1.expect(statsSink).to.be.an("object");
        chai_1.expect(statsSink.counter).to.be.a("function");
        chai_1.expect(statsSink.gauge).to.be.a("function");
        chai_1.expect(statsSink.histogram).to.be.a("function");
    });
    describe("emitting packets", () => {
        let server;
        let statsSink;
        let logger;
        before((done) => {
            logger = new Logger_1.MuteLogger();
            server = dgram.createSocket("udp4");
            server.bind(() => {
                const address = server.address();
                statsSink = new StatsdStatsSink_1.StatsdStatsSink({
                    hostname: address.address,
                    port: address.port,
                    socketType: "udp4",
                    logger,
                });
                done();
            });
        });
        describe("from a counter", () => {
            let counter;
            before(() => {
                counter = statsSink.counter({
                    name: "some.awesome.counter",
                    help: "Just testing ...",
                    labelNames: ["key1", "key2"],
                });
            });
            it("will emit increments", (done) => {
                server.once("message", (data) => {
                    const message = data.toString("utf8");
                    chai_1.expect(message).to.equal("some.awesome.counter,key1=value1,key2=value2:+1337|c");
                    done();
                });
                counter.inc({ key1: "value1", key2: "value2" }, 1337);
            });
            it("will emit resets", (done) => {
                server.once("message", (data) => {
                    const message = data.toString("utf8");
                    chai_1.expect(message).to.equal("some.awesome.counter,key1=value1:0|c");
                    done();
                });
                counter.reset({ key1: "value1" });
            });
            it("will warn if given label values with a comma", (done) => {
                logger.once("message", (level, msg) => {
                    if (level === "warn") {
                        chai_1.expect(msg).to.equal('Skipping label "key1", its value cannot contain comma (,) or equal-sign (=), it was "label-value-with-a,comma"');
                        done();
                    }
                });
                counter.reset({ key1: "label-value-with-a,comma" });
            });
            it("will warn if given label values with an equal-sign", (done) => {
                logger.once("message", (level, msg) => {
                    if (level === "warn") {
                        chai_1.expect(msg).to.equal('Skipping label "key1", its value cannot contain comma (,) or equal-sign (=), it was "label-value-with-an=equal-sign"');
                        done();
                    }
                });
                counter.reset({ key1: "label-value-with-an=equal-sign" });
            });
        });
        describe("from a gauge", () => {
            let gauge;
            before(() => {
                gauge = statsSink.gauge({
                    name: "some.awesome.gauge",
                    help: "Just testing ...",
                    labelNames: ["key1", "key2"],
                });
            });
            it("will emit increments", (done) => {
                server.once("message", (data) => {
                    const message = data.toString("utf8");
                    chai_1.expect(message).to.equal("some.awesome.gauge,key1=increment,key2=value2:+1337|g");
                    done();
                });
                gauge.inc({ key1: "increment", key2: "value2" }, 1337);
            });
            it("will emit decrements", (done) => {
                server.once("message", (data) => {
                    const message = data.toString("utf8");
                    chai_1.expect(message).to.equal("some.awesome.gauge,key1=decrement,key2=value2:-123|g");
                    done();
                });
                gauge.dec({ key1: "decrement", key2: "value2" }, 123);
            });
            it("will emit sets", (done) => {
                server.once("message", (data) => {
                    const message = data.toString("utf8");
                    chai_1.expect(message).to.equal("some.awesome.gauge,key1=set:7331|g");
                    done();
                });
                gauge.set({ key1: "set" }, 7331);
            });
            it("will emit resets", (done) => {
                server.once("message", (data) => {
                    const message = data.toString("utf8");
                    chai_1.expect(message).to.equal("some.awesome.gauge,key1=reset:0|g");
                    done();
                });
                gauge.reset({ key1: "reset" });
            });
        });
        describe("from a histogram", () => {
            let histogram;
            before(() => {
                histogram = statsSink.histogram({
                    name: "some.awesome.histogram",
                    help: "Just testing ...",
                    labelNames: ["key1", "key2"],
                });
            });
            it("will emit observations", (done) => {
                server.once("message", (data) => {
                    const message = data.toString("utf8");
                    chai_1.expect(message).to.equal("some.awesome.histogram,key1=histogram:1234|ms");
                    done();
                });
                histogram.observe({ key1: "histogram" }, 1234);
            });
        });
    });
});
//# sourceMappingURL=StatsdStatsSink.spec.js.map