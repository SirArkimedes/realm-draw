"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const StandaloneStats_1 = require("./StandaloneStats");
describe("StandaloneStats", () => {
    it("can be instantiated", () => {
        new StandaloneStats_1.StandaloneStats();
    });
    it("can respond to non-existing stats", () => __awaiter(this, void 0, void 0, function* () {
        const instance = new StandaloneStats_1.StandaloneStats();
        const values = yield instance.getInstantValues("whatever");
        chai_1.expect(values).to.be.an("array").with.length(0);
    }));
    it("can set, increment, read and reset a counter value", () => __awaiter(this, void 0, void 0, function* () {
        const instance = new StandaloneStats_1.StandaloneStats();
        const counter = instance.counter({
            name: "test_metric",
            help: "Just testing",
        });
        counter.inc({}, 10);
        counter.inc({});
        const values = yield instance.getInstantValues("test_metric");
        chai_1.expect(values).to.be.an("array").of.length(1);
        chai_1.expect(values[0]).to.be.an("object").with.all.keys("labels", "value");
        chai_1.expect(values[0].labels).to.be.an("object").empty;
        chai_1.expect(values[0].value).to.equal(11);
        counter.reset({});
        const valuesAfter = yield instance.getInstantValues("test_metric");
        chai_1.expect(valuesAfter).to.be.an("array").of.length(1);
        chai_1.expect(valuesAfter[0]).to.be.an("object").with.all.keys("labels", "value");
        chai_1.expect(valuesAfter[0].value).to.equal(0);
    }));
    it("can use a counter and gauge", () => __awaiter(this, void 0, void 0, function* () {
        const instance = new StandaloneStats_1.StandaloneStats();
        const counter = instance.counter({ name: "testing_counter", help: "..." });
        const gauge = instance.gauge({ name: "testing_gauge", help: "..." });
        let accumulated = 0;
        counter.inc({}, 3);
        counter.inc({}, 5);
        const counterValue = yield instance.getInstantValues("testing_counter");
        accumulated += counterValue[0].value;
        chai_1.expect(accumulated).to.equal(8);
        counter.reset({});
        counter.inc({}, 7);
        accumulated += (yield instance.getInstantValues("testing_counter"))[0].value;
        chai_1.expect(accumulated).to.equal(15);
        chai_1.expect(counterValue[0].value).to.equal(8);
        gauge.inc({}, 9);
        accumulated += (yield instance.getInstantValues("testing_gauge"))[0].value;
        chai_1.expect(accumulated).to.equal(24);
        gauge.reset({});
        gauge.dec({}, 23);
        accumulated += (yield instance.getInstantValues("testing_gauge"))[0].value;
        chai_1.expect(accumulated).to.equal(1);
    }));
    it("can distinguish different label values on the same counter", () => __awaiter(this, void 0, void 0, function* () {
        const instance = new StandaloneStats_1.StandaloneStats();
        const counter = instance.counter({
            name: "test_metric",
            help: "Just testing",
            labelNames: ["someLabel"],
        });
        counter.inc({ someLabel: "A" }, 7);
        counter.inc({ someLabel: "B" }, 9);
        const valuesA = yield instance.getInstantValues("test_metric", { someLabel: "A" });
        chai_1.expect(valuesA).to.be.an("array").of.length(1);
        chai_1.expect(valuesA[0]).to.be.an("object").with.all.keys("labels", "value");
        chai_1.expect(valuesA[0].value).to.equal(7);
        chai_1.expect(valuesA[0].labels).to.be.an("object").with.all.keys("someLabel");
        chai_1.expect(valuesA[0].labels.someLabel).to.equal("A");
        const valuesB = yield instance.getInstantValues("test_metric", { someLabel: "B" });
        chai_1.expect(valuesB).to.be.an("array").of.length(1);
        chai_1.expect(valuesB[0]).to.be.an("object").with.all.keys("labels", "value");
        chai_1.expect(valuesB[0].value).to.equal(9);
        chai_1.expect(valuesB[0].labels).to.be.an("object").with.all.keys("someLabel");
        chai_1.expect(valuesB[0].labels.someLabel).to.equal("B");
        const allValues = yield instance.getInstantValues("test_metric");
        chai_1.expect(allValues).to.be.an("array").of.length(2);
        chai_1.expect(allValues[0]).to.be.an("object").with.all.keys("labels", "value");
        chai_1.expect(allValues[0].labels).to.be.an("object").with.all.keys("someLabel");
        chai_1.expect(allValues[1]).to.be.an("object").with.all.keys("labels", "value");
        chai_1.expect(allValues[1].labels).to.be.an("object").with.all.keys("someLabel");
        chai_1.expect(allValues[0].value + allValues[1].value).to.equal(7 + 9);
    }));
    it("fails if a counter is called with an unexpected label", () => {
        const instance = new StandaloneStats_1.StandaloneStats();
        const counter = instance.counter({
            name: "test_metric",
            help: "Just testing",
            labelNames: ["someLabel"],
        });
        chai_1.expect(() => {
            counter.inc({ anotherLabel: "w00t" }, 10);
        }).throws("Unexpected label");
    });
});
//# sourceMappingURL=StandaloneStats.spec.js.map