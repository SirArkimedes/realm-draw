"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const superagent = require("superagent");
const __1 = require("..");
const Logger_1 = require("../shared/Logger");
const Token_1 = require("../shared/Token");
const StatsService_1 = require("./StatsService");
describe("StatsService", () => {
    let server;
    let adminToken;
    afterEach(() => __awaiter(this, void 0, void 0, function* () {
        if (server) {
            yield server.shutdown();
            server = null;
        }
    }));
    function startServer(params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            server = new __1.TestServer();
            yield server.start(params);
            adminToken = new Token_1.RefreshToken({
                isAdmin: true,
                identity: "admin-identity",
                appId: "io.realm.ros.tests",
            }).sign(server.privateKey);
        });
    }
    describe("getInstantValues", () => {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () {
            yield startServer();
        }));
        it("fails when metric name is not specified", (done) => {
            superagent.get(`${server.url}/stats/instant`)
                .set("Authorization", adminToken)
                .catch((err) => {
                const { response } = err;
                chai_1.expect(response).to.be.an("object");
                chai_1.expect(response.status).to.equal(404);
                done();
            }).then(null, done);
        });
        it("responds when metric name is unknown", () => __awaiter(this, void 0, void 0, function* () {
            const response = yield superagent
                .get(`${server.url}/stats/instant/test-metric`)
                .set("Authorization", adminToken);
            chai_1.expect(response.status).to.equal(200);
            chai_1.expect(response.body).to.be.an("object").with.all.keys("test-metric");
        }));
        describe("with metrics", () => __awaiter(this, void 0, void 0, function* () {
            beforeEach(() => {
                const statsSink = server.getStatsSink();
                const counter = statsSink.counter({
                    name: "test-counter",
                    help: "Just testing ...",
                    labelNames: ["key1", "key2"],
                });
                counter.inc({ key1: "A", key2: "A" }, 7);
                counter.inc({ key1: "A", key2: "B" }, 9);
                counter.inc({ key1: "B", key2: "A" }, 13);
                counter.inc({ key1: "B", key2: "B" }, 15);
                const gauge = statsSink.gauge({
                    name: "test-guage",
                    help: "Just testing ...",
                    labelNames: ["key1", "key2"],
                });
                gauge.set({ key1: "A", key2: "A" }, 21);
                gauge.inc({ key1: "A", key2: "A" }, 1);
                gauge.set({ key1: "A" }, 3);
            });
            it("responds for single counter without labels filter", () => __awaiter(this, void 0, void 0, function* () {
                const response = yield superagent
                    .get(`${server.url}/stats/instant/test-counter`)
                    .set("Authorization", adminToken);
                chai_1.expect(response.status).to.equal(200);
                chai_1.expect(response.body).to.be.an("object").with.all.keys("test-counter");
                const counter = response.body["test-counter"];
                chai_1.expect(counter).to.be.an("array").with.length(4);
                const sum = counter[0].value + counter[1].value + counter[2].value + counter[3].value;
                chai_1.expect(sum).to.equal(7 + 9 + 13 + 15);
            }));
            it("responds for two metrics with a labels filter", () => __awaiter(this, void 0, void 0, function* () {
                const response = yield superagent
                    .get(`${server.url}/stats/instant/test-counter,test-guage?key1=A&key2=A`)
                    .set("Authorization", adminToken);
                chai_1.expect(response.status).to.equal(200);
                chai_1.expect(response.body).to.be.an("object").with.all.keys("test-counter", "test-guage");
                const counter = response.body["test-counter"];
                const guage = response.body["test-guage"];
                chai_1.expect(counter).to.be.an("array").with.length(1);
                chai_1.expect(counter[0].value).to.equal(7);
                chai_1.expect(guage).to.be.an("array").with.length(1);
                chai_1.expect(guage[0].value).to.equal(22);
            }));
            it("responds for two metrics with a sub-set labels filter", () => __awaiter(this, void 0, void 0, function* () {
                const response = yield superagent
                    .get(`${server.url}/stats/instant/test-counter,test-guage?key1=A`)
                    .set("Authorization", adminToken);
                chai_1.expect(response.status).to.equal(200);
                chai_1.expect(response.body).to.be.an("object").with.all.keys("test-counter", "test-guage");
                const counter = response.body["test-counter"];
                const guage = response.body["test-guage"];
                chai_1.expect(counter).to.be.an("array").with.length(2);
                chai_1.expect(counter[0].value + counter[1].value).to.equal(7 + 9);
                chai_1.expect(guage).to.be.an("array").with.length(2);
                chai_1.expect(guage[0].value + guage[1].value).to.equal(22 + 3);
            }));
        }));
    });
    describe("reportRealmStateSize", () => {
        before(() => __awaiter(this, void 0, void 0, function* () {
            yield startServer({
                logLevel: "detail",
                logger: new Logger_1.MuteLogger(),
                enableRealmSizeReporting: true,
            });
        }));
        it("makes the sync server compute state size", () => __awaiter(this, void 0, void 0, function* () {
            const logPromise = new Promise(resolve => {
                server.logger.on("message", (level, message, context) => {
                    if (context.service === "sync" && message.indexOf("Done computing state size of") >= 0) {
                        resolve();
                    }
                });
            });
            const requestPromise = superagent
                .post(`${server.url}/stats/report-realm-state-size`)
                .set("Authorization", adminToken)
                .then(response => {
                chai_1.expect(response.status).to.equal(200);
                chai_1.expect(response.body).to.be.an("object").with.keys("syncServiceCount");
                chai_1.expect(response.body.syncServiceCount).to.be.a("number");
            });
            return Promise.all([logPromise, requestPromise]);
        }));
    });
    describe("extended with extra labels", () => {
        before(() => __awaiter(this, void 0, void 0, function* () {
            class ExtendedStatsService extends StatsService_1.StatsService {
                getExtraLabels(req) {
                    chai_1.expect(req).to.be.an("object");
                    return { someName: "someValue" };
                }
            }
            yield startServer({
                services: [new ExtendedStatsService()],
                disableTokenRevocation: true,
            });
            const statsSink = server.getStatsSink();
            const counter = statsSink.counter({
                name: "test-counter",
                help: "Just testing ...",
                labelNames: ["someName", "key"],
            });
            counter.inc({ someName: "someValue", key: "A" }, 7);
            counter.inc({ someName: "someOtherValue", key: "B" }, 9);
        }));
        it("will respond filtered by the labels from the extension", () => __awaiter(this, void 0, void 0, function* () {
            const response = yield superagent
                .get(`${server.url}/stats/instant/test-counter`)
                .set("Authorization", adminToken);
            chai_1.expect(response.status).to.equal(200);
            chai_1.expect(response.body).to.be.an("object").with.all.keys("test-counter");
            const counter = response.body["test-counter"];
            chai_1.expect(counter).to.deep.equal([{
                    labels: { someName: "someValue", key: "A" },
                    value: 7,
                }]);
        }));
    });
});
//# sourceMappingURL=StatsService.spec.js.map