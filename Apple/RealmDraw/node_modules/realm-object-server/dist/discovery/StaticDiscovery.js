"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ServiceWatch_1 = require("./ServiceWatch");
const Discovery_1 = require("./Discovery");
const URI = require("urijs");
function tags2Labels(tags) {
    const labels = {};
    for (const t of tags) {
        const pair = t.split("=");
        if (pair.length === 2) {
            labels[pair[0]] = pair[1];
        }
    }
    return labels;
}
class StaticDiscovery extends Discovery_1.Discovery {
    constructor(params) {
        super();
        this.config = params.config;
    }
    registerService(service, serverAddress, serverPort) {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    deregisterService(service) {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    findAll(name, tags) {
        return __awaiter(this, void 0, void 0, function* () {
            const handles = [];
            const url2Handle = (name, tags, url) => {
                if (url) {
                    const uri = new URI(url);
                    return {
                        name, tags,
                        address: uri.hostname(),
                        port: Number(uri.port()),
                    };
                }
            };
            if (name === "sync") {
                const labels = tags2Labels(tags || []);
                if (labels.label) {
                    handles.push(url2Handle(name, [`label=${labels.label}`], this.config.sync[labels.label]));
                }
                else {
                    for (const groupName in this.config.sync) {
                        handles.push(url2Handle(name, [`label=${groupName}`], this.config.sync[groupName]));
                    }
                }
            }
            else if (this.config[name]) {
                handles.push(url2Handle(name, tags, this.config[name]));
            }
            else {
                handles.push(url2Handle(name, tags, this.config.default));
            }
            return handles;
        });
    }
    watchService(name, tags) {
        const watch = new ServiceWatch_1.ServiceWatch(name, tags);
        this.find(name, tags).then((handle) => {
            if (handle) {
                watch.emit("available", handle);
            }
        });
        return watch;
    }
}
exports.StaticDiscovery = StaticDiscovery;
//# sourceMappingURL=StaticDiscovery.js.map